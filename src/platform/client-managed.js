import logger from '../util/logger';
import { getSelectors } from './selectors';

/**
 * Client-managed Qlik Sense platform adapter.
 *
 * Encapsulates all DOM interaction and Sense API calls specific to
 * Qlik Sense Enterprise on Windows (client-managed).
 */

// ---------------------------------------------------------------------------
// Version detection
// ---------------------------------------------------------------------------

/**
 * Cached Sense version info — populated once by {@link getSenseVersion}.
 *
 * @type {{ version: string, releaseLabel: string } | null}
 */
let cachedVersionInfo = null;

/**
 * Detect the running Qlik Sense version by fetching the product-info manifest.
 *
 * The file `/resources/autogenerated/product-info.js` is an AMD module that
 * wraps a JSON object.  We strip the AMD `define([], ...)` wrapper and parse
 * the JSON payload to extract `composition.version` (e.g. "14.254.6") and
 * `composition.releaseLabel` (e.g. "February 2024 Patch 2").
 *
 * @returns {Promise<{ version: string, releaseLabel: string } | null>}
 *   Version info, or null when detection fails.
 */
export async function getSenseVersion() {
    if (cachedVersionInfo) {
        return cachedVersionInfo;
    }

    try {
        const resp = await fetch('/resources/autogenerated/product-info.js');
        if (!resp.ok) {
            logger.warn(`product-info.js fetch failed: ${resp.status}`);
            return null;
        }

        const text = await resp.text();

        // Strip AMD wrapper:  define([], function() { return <JSON>; });
        const jsonMatch = text.match(/return\s*(\{[\s\S]*\})\s*;?\s*\}\s*\)\s*;?\s*$/);
        if (!jsonMatch) {
            logger.warn('Could not parse product-info.js — unexpected format');
            return null;
        }

        const info = JSON.parse(jsonMatch[1]);
        const version = info?.composition?.version ?? null;
        const releaseLabel = info?.composition?.releaseLabel ?? '';

        if (version) {
            cachedVersionInfo = { version, releaseLabel };
            logger.info(`Sense version detected: ${version} (${releaseLabel})`);
            return cachedVersionInfo;
        }

        logger.warn('product-info.js did not contain a version');
        return null;
    } catch (err) {
        logger.warn('Sense version detection failed:', err);
        return null;
    }
}

// ---------------------------------------------------------------------------
// Code-path resolution (version ranges)
// ---------------------------------------------------------------------------

/**
 * Version-range-to-code-path mapping.
 *
 * Each entry specifies an inclusive range `[minVersion, maxVersion]` and the
 * name of the code-path in the selectors registry that applies.
 * Ranges are evaluated top-to-bottom; the first match wins.
 * If no range matches, `'default'` is returned.
 *
 * @type {Array<{ minVersion: string, maxVersion: string, codePath: string }>}
 */
const versionRanges = [
    // Example for a future code path:
    // { minVersion: '15.0.0', maxVersion: '99.999.999', codePath: 'future' },
];

/**
 * Simple semver comparison (major.minor.patch).
 *
 * @param {string} a - Version string, e.g. "14.254.6".
 * @param {string} b - Version string.
 * @returns {number} Negative if a < b, 0 if equal, positive if a > b.
 */
function compareVersions(a, b) {
    const pa = a.split('.').map(Number);
    const pb = b.split('.').map(Number);
    for (let i = 0; i < 3; i++) {
        const diff = (pa[i] || 0) - (pb[i] || 0);
        if (diff !== 0) return diff;
    }
    return 0;
}

/**
 * Resolve the code-path name for a given Sense version.
 *
 * @param {string | null} version - Sense version string (e.g. "14.254.6").
 * @returns {string} Code-path name to use in {@link getSelectors}.
 */
export function resolveCodePath(version) {
    if (!version) return 'default';

    for (const range of versionRanges) {
        if (
            compareVersions(version, range.minVersion) >= 0 &&
            compareVersions(version, range.maxVersion) <= 0
        ) {
            logger.debug(`Version ${version} matched code path "${range.codePath}"`);
            return range.codePath;
        }
    }

    return 'default';
}

// ---------------------------------------------------------------------------
// Sheet / object helpers
// ---------------------------------------------------------------------------

/**
 * Get the current sheet ID from URL, Qlik API, or DOM.
 *
 * @returns {string|null} The sheet ID or null.
 */
export function getCurrentSheetId() {
    const url = window.location.href;

    // Pattern 1: /sheet/ID
    const match1 = url.match(/\/sheet\/([a-zA-Z0-9-]+)/);
    if (match1) {
        logger.debug('Sheet ID via URL pattern:', match1[1]);
        return match1[1];
    }

    // Pattern 2: Qlik global API
    try {
        if (window.qlik?.navigation?.getCurrentSheetId) {
            const qlikSheetId = window.qlik.navigation.getCurrentSheetId();
            const id = typeof qlikSheetId === 'string' ? qlikSheetId : qlikSheetId?.id;
            if (id) {
                logger.debug('Sheet ID via Qlik API:', id);
                return id;
            }
        }
    } catch (_) {}

    // Pattern 3: DOM fallback
    try {
        const selectors = getSelectors('client-managed');
        const sheetEl = document.querySelector(selectors.sheetContainer);
        if (sheetEl) {
            const domId =
                sheetEl.getAttribute('data-id') ||
                sheetEl.getAttribute('data-qid') ||
                sheetEl.getAttribute('id')?.replace('qv-sheet-', '');
            if (domId && domId.length > 5) {
                logger.debug('Sheet ID via DOM:', domId);
                return domId;
            }
        }
    } catch (_) {}

    logger.debug('Could not detect sheet ID');
    return null;
}

/**
 * Get the list of objects on the current sheet.
 *
 * @param {object} app - Enigma app object from useApp().
 * @returns {Promise<Array<{id: string, title: string, type: string}>>} Sheet objects.
 */
export async function getSheetObjects(app) {
    const excludeTypes = [
        'sheet',
        'story',
        'appprops',
        'loadmodel',
        'dimension',
        'measure',
        'masterobject',
        'qix-system-dimension',
        'onboard-qs',
    ];

    try {
        let infos = await app.getAllInfos();
        const sheetId = getCurrentSheetId();

        if (sheetId) {
            try {
                const sheetObj = await app.getObject(sheetId);
                const sheetLayout = await sheetObj.getLayout();
                let sheetObjectIds = (sheetLayout.cells || []).map((c) => c.name);

                if (sheetLayout.qChildList?.qItems) {
                    const childIds = sheetLayout.qChildList.qItems.map((item) => item.qInfo.qId);
                    sheetObjectIds = [...new Set([...sheetObjectIds, ...childIds])];
                }

                const filtered = infos.filter((info) => sheetObjectIds.includes(info.qId));
                if (filtered.length > 0) {
                    infos = filtered;
                }
            } catch (e) {
                logger.warn('Could not filter by sheet:', e);
            }
        }

        const objects = infos
            .filter((info) => !excludeTypes.includes(info.qType) && !info.qType.includes('system'))
            .map((info) => ({
                id: info.qId,
                title: info.qTitle || info.qId,
                type: info.qType,
            }));

        // Enrich titles for objects without a proper title
        if (objects.length < 100) {
            const enriched = await Promise.all(
                objects.map(async (obj) => {
                    if (obj.title === obj.id) {
                        try {
                            const objHandle = await app.getObject(obj.id);
                            const layout = await objHandle.getLayout();
                            return {
                                ...obj,
                                title: layout.title || layout.qMeta?.title || obj.id,
                                type: layout.qInfo?.qType || obj.type,
                            };
                        } catch (_) {}
                    }
                    return obj;
                })
            );
            return enriched.sort((a, b) => a.title.localeCompare(b.title));
        }

        return objects.sort((a, b) => a.title.localeCompare(b.title));
    } catch (err) {
        logger.error('Failed to get sheet objects:', err);
        return [];
    }
}

/**
 * Get the CSS selector for a specific Qlik object by ID.
 * In client-managed Sense, object IDs are embedded in CSS class names
 * on .qv-object elements (e.g., .qv-object-APdJrgp), NOT in data-id attributes.
 *
 * @param {string} objectId - The Qlik object ID.
 * @param {string} [version] - Sense version for version-specific selectors.
 * @returns {string} CSS selector string.
 */
export function getObjectSelector(objectId, version) {
    const codePath = resolveCodePath(version);
    const sels = getSelectors('client-managed', codePath);
    return sels.objectById(objectId);
}

/**
 * Detect whether we are in edit mode or analysis mode.
 *
 * @param {object} options - Options from useOptions().
 * @returns {boolean} True if in edit mode.
 */
export function isEditMode(options) {
    if (options.readOnly !== undefined) {
        return !options.readOnly;
    }
    return window.location.href.includes('/state/edit');
}

/**
 * Inject a <style> element into the document head.
 *
 * @param {string} css - CSS string to inject.
 * @param {string} id - Unique ID for the style element (prevents duplicates).
 */
export function injectCSS(css, id) {
    if (document.getElementById(id)) return;
    const style = document.createElement('style');
    style.id = id;
    style.textContent = css;
    document.head.appendChild(style);
}
